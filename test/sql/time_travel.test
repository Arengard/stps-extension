# name: test/sql/time_travel.test
# description: Test time travel functions
# group: [stps]

require stps

# Create a test table with data
statement ok
CREATE TABLE tt_test (id INTEGER, name VARCHAR, email VARCHAR);

statement ok
INSERT INTO tt_test VALUES (1, 'Alice', 'alice@example.com'), (2, 'Bob', 'bob@example.com');

# Enable time travel tracking
statement ok
SELECT stps_tt_enable('tt_test', 'id');

# Verify metadata table was created
query ITII
SELECT table_name, pk_column, current_version, (created_at IS NOT NULL)::INT FROM _stps_tt_tables;
----
tt_test	id	0	1

# Verify history table was created with initial snapshot
query I
SELECT COUNT(*) FROM _stps_history_tt_test;
----
2

# Verify initial snapshot has correct data
query ITIT
SELECT id, name, _tt_version, _tt_operation FROM _stps_history_tt_test ORDER BY id;
----
1	Alice	0	INSERT
2	Bob	0	INSERT

# Test stps_tt_disable
statement ok
CREATE TABLE tt_disable_test (id INTEGER, val VARCHAR);

statement ok
SELECT stps_tt_enable('tt_disable_test', 'id');

statement ok
SELECT stps_tt_disable('tt_disable_test');

# Metadata should be removed
query I
SELECT COUNT(*) FROM _stps_tt_tables WHERE table_name = 'tt_disable_test';
----
0

# History table should be dropped
statement error
SELECT * FROM _stps_history_tt_disable_test;
----

# Error cases: enable on non-existent table
statement error
SELECT stps_tt_enable('nonexistent_table', 'id');
----

# Error cases: enable with non-existent column
statement error
SELECT stps_tt_enable('tt_test', 'nonexistent_col');
----

# Error cases: enable on already tracked table
statement error
SELECT stps_tt_enable('tt_test', 'id');
----

# Error cases: disable on non-tracked table
statement error
SELECT stps_tt_disable('some_random_table');
----

# ============================================================
# Test transparent DML tracking via optimizer extension
# ============================================================

statement ok
CREATE TABLE tt_dml (id INTEGER, name VARCHAR, score INTEGER);

statement ok
SELECT stps_tt_enable('tt_dml', 'id');

# INSERT should be tracked automatically
statement ok
INSERT INTO tt_dml VALUES (1, 'Alice', 100);

# Trigger flush by querying history — the SELECT goes through the optimizer
# which flushes the pending capture from the INSERT above
query I
SELECT COUNT(*) FROM _stps_history_tt_dml WHERE _tt_operation = 'SNAPSHOT' AND _tt_version = 1;
----
1

# UPDATE should be tracked
statement ok
UPDATE tt_dml SET score = 200 WHERE id = 1;

# Trigger flush
query I
SELECT COUNT(*) FROM _stps_history_tt_dml WHERE _tt_version = 2;
----
1

# DELETE should be tracked
statement ok
DELETE FROM tt_dml WHERE id = 1;

# Trigger flush — should have a DELETE marker
query I
SELECT COUNT(*) FROM _stps_history_tt_dml WHERE _tt_operation = 'DELETE' AND _tt_version = 3;
----
1

# Cleanup DML test
statement ok
SELECT stps_tt_disable('tt_dml');

statement ok
DROP TABLE tt_dml;

# ============================================================
# Cleanup from earlier tests
# ============================================================

# Cleanup
statement ok
SELECT stps_tt_disable('tt_test');

statement ok
DROP TABLE tt_test;

statement ok
DROP TABLE tt_disable_test;
