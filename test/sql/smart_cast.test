# name: test/sql/smart_cast.test
# description: Test stps_smart_cast functions
# group: [stps]

require stps

# Test boolean parsing via scalar function
query I
SELECT stps_smart_cast('true');
----
true

query I
SELECT stps_smart_cast('false');
----
false

query I
SELECT stps_smart_cast('yes');
----
true

query I
SELECT stps_smart_cast('no');
----
false

query I
SELECT stps_smart_cast('ja');
----
true

query I
SELECT stps_smart_cast('nein');
----
false

query I
SELECT stps_smart_cast('1')::BOOLEAN;
----
true

query I
SELECT stps_smart_cast('0')::BOOLEAN;
----
false

# Integer parsing tests
query I
SELECT stps_smart_cast('123');
----
123

query I
SELECT stps_smart_cast('-456');
----
-456

query I
SELECT stps_smart_cast('1234');
----
1234

# German thousands separator (context needed for ambiguous)
query I
SELECT stps_smart_cast('1.234.567');
----
1234567

# Large numbers in German format should not be confused with dates
query I
SELECT stps_smart_cast('15.012.024');
----
15012024

query I
SELECT stps_smart_cast('12.345.678');
----
12345678

query I
SELECT stps_smart_cast('1.000.000.000');
----
1000000000

# Invalid number formats should remain as VARCHAR, not be parsed as dates
query I
SELECT stps_smart_cast('1.23.456');
----
1.23.456

query I
SELECT stps_smart_cast('1.2.345');
----
1.2.345

query I
SELECT stps_smart_cast('12.3.456');
----
12.3.456

# Double parsing tests - US format
query I
SELECT stps_smart_cast('123.45');
----
123.450000

query I
SELECT stps_smart_cast('1,234.56');
----
1234.560000

# Double parsing tests - German format
query I
SELECT stps_smart_cast('123,45');
----
123.450000

query I
SELECT stps_smart_cast('1.234,56');
----
1234.560000

# Percentage conversion
query I
SELECT stps_smart_cast('45%');
----
0.450000

query I
SELECT stps_smart_cast('100%');
----
1.000000

# Currency stripping
query I
SELECT stps_smart_cast('$123.45');
----
123.450000

query I
SELECT stps_smart_cast('$1,234.56');
----
1234.560000

# Date parsing tests - ISO format
query I
SELECT stps_smart_cast('2024-01-15');
----
2024-01-15

# German dot format
query I
SELECT stps_smart_cast('15.01.2024');
----
2024-01-15

query I
SELECT stps_smart_cast('15.1.2024');
----
2024-01-15

# US slash format
query I
SELECT stps_smart_cast('01/15/2024');
----
2024-01-15

# Compact format - detected as integer (no separators to distinguish from date)
query I
SELECT stps_smart_cast('20240115');
----
20240115

# Two-digit year
query I
SELECT stps_smart_cast('15.01.24');
----
2024-01-15

# Written month - English
query I
SELECT stps_smart_cast('15 Jan 2024');
----
2024-01-15

query I
SELECT stps_smart_cast('January 15, 2024');
----
2024-01-15

# Written month - German
query I
SELECT stps_smart_cast('15. Januar 2024');
----
2024-01-15

# Timestamp parsing
query I
SELECT stps_smart_cast('2024-01-15 10:30:00');
----
2024-01-15 10:30:00

query I
SELECT stps_smart_cast('2024-01-15T10:30:00');
----
2024-01-15 10:30:00

query I
SELECT stps_smart_cast('15.01.2024 10:30');
----
2024-01-15 10:30:00

# UUID parsing
query I
SELECT stps_smart_cast('550e8400-e29b-41d4-a716-446655440000')::UUID IS NOT NULL;
----
true

# Scalar function with explicit type
query I
SELECT stps_smart_cast('123', 'INTEGER');
----
123

query I
SELECT stps_smart_cast('1.234,56', 'DOUBLE');
----
1234.560000

query I
SELECT stps_smart_cast('invalid', 'INTEGER') IS NULL;
----
true

# ============================================
# Table function tests
# ============================================

# Create test table with various data types
statement ok
CREATE TABLE test_smart_cast AS SELECT
    '123' as num_col,
    'true' as bool_col,
    '2024-01-15' as date_col,
    '1.234,56' as german_num,
    'hello' as text_col;

statement ok
INSERT INTO test_smart_cast VALUES ('456', 'false', '2024-02-20', '2.345,67', 'world');

# Test stps_smart_cast_analyze - should detect types correctly
query TTTIII
SELECT column_name, original_type, detected_type, total_rows, null_count, cast_success_count
FROM stps_smart_cast_analyze('test_smart_cast')
ORDER BY column_name;
----
bool_col	VARCHAR	BOOLEAN	2	0	2
date_col	VARCHAR	DATE	2	0	2
german_num	VARCHAR	DOUBLE	2	0	2
num_col	VARCHAR	INTEGER	2	0	2
text_col	VARCHAR	VARCHAR	2	0	2

# Test stps_smart_cast table function - should cast columns to detected types
query IIIII
SELECT num_col, bool_col, german_num, date_col, text_col FROM stps_smart_cast('test_smart_cast');
----
123	true	1234.56	2024-01-15	hello
456	false	2345.67	2024-02-20	world

# Clean up
statement ok
DROP TABLE test_smart_cast;

# Test with NULL values
statement ok
CREATE TABLE test_nulls AS SELECT '123' as a, NULL as b UNION ALL SELECT NULL, '456';

query TTTIII
SELECT column_name, detected_type, total_rows, null_count, cast_success_count, cast_failure_count
FROM stps_smart_cast_analyze('test_nulls')
ORDER BY column_name;
----
a	INTEGER	2	1	1	0
b	INTEGER	2	1	1	0

statement ok
DROP TABLE test_nulls;

# Test with mixed types that should stay VARCHAR
statement ok
CREATE TABLE test_mixed AS SELECT 'hello' as col UNION ALL SELECT '123' UNION ALL SELECT 'world';

query TTTIII
SELECT column_name, detected_type, total_rows, null_count, cast_success_count, cast_failure_count
FROM stps_smart_cast_analyze('test_mixed');
----
col	VARCHAR	3	0	3	0

statement ok
DROP TABLE test_mixed;
